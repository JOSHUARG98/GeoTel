
/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include<stdbool.h>
#include "stm32l4xx.h"
#include <GPIOx.h>
#include <I2Cx.h>
#include <CANx.h>
#include <SSD1306.h>
#include <MPU6050.h>
#include <NVIC.h>
#include <USARTx.h>

//Simplified Definitions
#define GPIO_MODER_INPUT				(0U)
#define GPIO_MODER_OUTPUT				(1U)
#define GPIO_OTYPER_PP                   0UL //Push pull
#define GPIO_OTYPER_OD                   1UL //Open Drain
#define GPIO_OSPEEDR_0                   0UL //
#define GPIO_MODER_MODE_AF               2UL //Alternate Function
#define GPIO_OSPEEDR_HS                  3UL //High Speed

#define MSI_16MHz  0x80

#define PID_0D 0x000D0102 //PID PARA LA VELOCIDAD
#define PID_0C 0x000C0102//PID PARA LAS RPM
#define PID_05 0x00050102//PID TEMPERATURA DEL LIQUIDO DE ENFRIAMIENTO
#define PID_2F 0x002F0102//PID DE NIVEL DE COMBUSTIBLE
#define PID_DTC 0x00000301 //PID PARA CODIGOS DTC


/*
 * COMADOS OBDII PID
 *
 * 0D	-	VELOCIDAD
 * 0C	-	RPM
 *
 *
 *
 *
 * */

/*********DECLARACION DE LAS FUNCIONES DEL MAIN PRINCIPAL************/

void MPU6050_Read_Ace_Giro(void);
void SecuanciaInicio(void);
void Init_Peripheral(void);
void Conf_Peripheral(void);
void delay(uint32_t n);
void sendMessage(uint8_t caseNumber);
void sendMessage_http_field1(uint16_t fieldValue);
void sendMessage_http_field2(uint16_t fieldValue);
void sendMessage_http_field3(uint16_t fieldValue);
void sendMessage_http_field4(uint16_t fieldValue);
void Get_Obdii_Data(void);
void Obdii_Message(uint32_t Obdii_pid);
void SSD1306_Refresh(void);
void Send_Telemetry (void);
void sendMessage_Cell(int number);

/*********FIN DE LAS FUNCIONES DEL MAIN PRINCIPAL************/

/*********DECLARACION DE VARIABLES GLOBALES ************/

/*****Variables para guardar la Aceleracion Lineal de X, Y, Z, directamente del MPU***************/

int16_t AC_X=0;
int16_t AC_Y=0;
int16_t AC_Z=0;

float AX=0;
float AY=0;
float AZ=0;


/*****Variables para guardar la Aceleracion Angular de X, Y, Z, directamente del MPU***************/
int16_t G_X=0;
int16_t G_Y=0;
int16_t G_Z=0;

float GX=0;
float GY=0;
float GZ=0;

int AB, FB, GB, W;
uint32_t receivedData0_L, receivedData0_H; // Variable para almacenar los datos recibidos
uint32_t receivedData1_L, receivedData1_H ; // Variable para almacenar los datos recibidos
uint8_t PID;


int Vel_Km=0;
int RPM_motor=0;
int Temp_liquido = 0;
int Combustible = 0;

int messageCounter = 0;       // Contador para alternar entre los mensajes
int C = 0;       // Contador para alternar entre los mensajes
uint8_t ByteA, ByteB, ByteC, ByteD;

uint32_t originalMessage_0D = 0x000D4103;  // Este es el valor original (32 bits)
uint32_t originalMessage_0C = 0x000C4104;  // Este es el valor original (32 bits)
uint32_t originalMessage_05 = 0x00054103;  // Este es el valor original (32 bits)
uint32_t originalMessage_2F = 0x002F4103;  // Este es el valor original (32 bits)

uint32_t frame;

uint8_t Velocidad=0;
uint8_t RPMs=0;
uint8_t Temperatura=0;
uint8_t Gasolina=0;
/*********FIN DE VARIABLES GLOBALES ************/
CAN_FIFOMailBox_TypeDef *FIFOmailBox0,*FIFOmailBox1;
uint32_t countdown = 10000; // Configura el tiempo del ciclo (10,000 "unidades", ajustable)

int main(void)
{

  // uint32_t caseNumber = 0;  // Inicializar el contador para el caso del s                                                                                 witch


/****************************INICIALIZACION Y CONFIGURACION DE PUERTOS Y PERIFERICOS************************************************/
/**********************************************************************************************************************************/
   Init_Peripheral();
   Conf_Peripheral();



    I2C_Init(I2C3); //Inicializacion de periferico I2C

    USARTx_CONF(USART3, USARTx_BRR_MSI_16MHz, USART3_IRQn, 7); // Configuracion del periferico Uart
    CANx_Init(CAN1); //Inicializacion del periferico CAN
	CANx_BitTiming_500Kz(CAN1); //Configuracion del can bit
	CANx_EnFIFO0Ints(CAN1); //interrupcion de la FIFO0
 	CANx_EnFIFO1Ints(CAN1); //Interrupcion de la FIFO1
	NVIC_Enable(CAN1_RX0_IRQn, 5); // Habilitar el vector de interrupcion
	NVIC_Enable(CAN1_RX1_IRQn, 4);  // Habilitar el vector de interrupcion
	GPIOC->ODR ^= GPIO_ODR_ODR_13;
	CLEAR_BIT(CAN1->MCR, CAN_MCR_INRQ);//limpia bandera de modo inicialización
	while(CAN1->MSR & CAN_MSR_INAK) {}; //Esperamos a que el bit CAN_MSR_INAK se limpie ****ENTRA


/****************************Uso de perifericos con librerias propias************************************************/
/**********************************************************************************************************************************/

/*************************CONFIGURACION DE FILTROS DE LAS FIFOS DE RECEPCION****************************/
/*******************************************************************************************************/
    CAN_FilterInit (CAN1, List_mode, Single_32bit, Fifo_0, 0); //CAN1, Mode , Scale, FIFO, Localidad
    CAN_SetFilterValue(CAN1, 0x7E8, 0x00, 0);  //CAN1, ID , MSK, Localidad

    CAN_FilterInit (CAN1, List_mode, Single_32bit, Fifo_1, 1); //CAN1, Mode , Scale, FIFO, Localidad
    CAN_SetFilterValue(CAN1, 0x0BB, 0x00, 1);  //CAN1, ID , MSK, Localidad

    CLEAR_BIT(CAN1->FMR, CAN_FMR_FINIT);


/*************************CONFIGURACION DE FILTROS DE LOS MILEBOX DE TRANSMICION***************************/
/*******************************************************************************************************/

   CAN_MailboxConfig(CAN1, false, 0x7DF, false, 0x0); //CAN1, ExtededID, IDE, RTR, Localidad
   CAN_SendData(CAN1, 8, 0x000D0102, 0x0); //CAN1, DLC , DATA, Localidad

   //CONFIGURAR MAILBOXS
   //frame = (originalMessage & 0x00FFFFFF) | ((uint32_t)Velocidad << 24);

   CAN_MailboxConfig(CAN1, false, 0x7E8, false, 0x1); //CAN1, ExtededID, IDE, RTR, Localidad
   //CAN_SendData(CAN1, 8, frame, 0x1); //CAN1, DLC , DATA, Localidad



/*************************USO DE PANTALLA OLED I2C SSD1306***********************************************/
/*******************************************************************************************************/

   SSD1306_Init(); //Funcion para configurar la pantalla
   SSD1306_Clear(); //Funcion para limpiar la pantalla
   SecuanciaInicio(); //Secuencia de la interfaz de usuario - inicio

   I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE0);
   SSD1306_PosCom(0);
   SSD1306_WriteString("! TELEMETRY SYSTEM !");

   I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE3);
   SSD1306_PosCom(0);
   SSD1306_WriteString(" VELOCIDAD :        ");

   I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE5);
   SSD1306_PosCom(0);
   SSD1306_WriteString(" RPMS :               ");

   I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE7);
   SSD1306_PosCom(0);
   SSD1306_WriteString(" GAS :                 ");


/*************************USO DE PANTALLA MPU6050***********************************************/
/*******************************************************************************************************/
   //MPU6050_Init(); //INICIALIZAR Y CONFIGURAR REGISTROSD EL MPU6050

   delay(1000000);
   sendStringUARTx(USART3, "AT+QGPS=1\r\n\0");

    while (!(GPIOC->IDR & GPIO_IDR_IDR_13)) {
        GPIOB->ODR ^= GPIO_ODR_ODR_13; //Conmuta led de usuario para indicar que esta listo para empezar despues de precionar boton
	    delay(300000);  // Se queda en este bucle mientras el botón está en 0 (no presionado)
    }
    delay(500000);  // Se queda en este bucle mientras el botón está en 0 (no presionado)
    while (1) {
        while (!(GPIOC->IDR & GPIO_IDR_IDR_13)) {
           GPIOB->ODR ^= GPIO_ODR_ODR_13; // BLINK LED
         //  MPU6050_Read_Ace_Giro(); //LECTURA DE GIROSCOPIO Y ACELEROMETRO


           /*
           ByteA = 0;
           ByteB = 0;
           ByteC = 0;
           ByteD = 0;

           Obdii_Message(PID_0D);
           delay(10000);

           ByteA = (receivedData0_L & 0xFF000000) >> 24;
           ByteB = (receivedData0_H & 0x000000FF);
           ByteC = (receivedData0_H & 0x0000FF00) >> 8;
           ByteD = (receivedData0_H & 0x00FF0000) >> 16;
           Vel_Km = ByteA;
           */
          // Get_Obdii_Data();
           SSD1306_Refresh();
           delay(5000000);
           messageCounter++;
           GPS_PET(messageCounter);
           // Asegurarse de que el contador esté dentro del rango 1-2
           if (messageCounter > 2) {
           	messageCounter = 0; // Reiniciar al primer caso
           }

        }

       C++;
       delay(1000000);
       sendStringUARTx(USART3, "AT+QGPSEND\r\n\0");
       delay(1000000);
       sendMessage_Cell(C);
       delay(1000000);
       sendStringUARTx(USART3, "AT+QGPS=1\r\n\0");
       delay(1000000);
    }
 }



void Init_Peripheral(void){
	  /*CONFIGURACIÓN DEL RELOJ*/
	  SystCLK_SetMSI(MSI_16MHz); //Configura 16MHz como  reloj
	  RCC_EnPort(GPIOB);//configura reloj en puerto B Para CANX
	  RCC_EnPort(GPIOC);//configura reloj en puerto C para I2C
	  RCC_En_I2C(I2C3); // Habilitar reloj al periférico I2C.
	  RCC_En_CANx(CAN1);// Habilitar reloj al periferico CAN
	  RCC_En_USARTx(USART3);
}

void Conf_Peripheral(void){
	 //Configuración de Led y boton de usuario
	//  GPIOx_InitIO(GPIOC, 2, GPIO_MODER_INPUT, false); //Botón de Usuario de Liese-duino
	 // GPIOx_InitIO(GPIOC, 13, GPIO_MODER_OUTPUT, false); //Led de usuario de Liese-duino

	  GPIOx_InitIO(GPIOC, 13, GPIO_MODER_INPUT, false); //Botón de Usuario de nucleo
	 GPIOx_InitIO(GPIOB, 13, GPIO_MODER_OUTPUT, false); //Led de usuario de nucleo


	  GPIOx_InitAF(GPIOC, 0, 1, 2, 4, false); /*Puerto C / PIN 0 / Configura Open Drain / High speed /  Función alterna 4 - I2C3_SCL / Habilita Resistencia de Pull -Up  */
	  GPIOx_InitAF(GPIOC, 1, 1, 2, 4, false); /*Puerto C / PIN 1 / Configura Open Drain / High speed /  Función alterna 4 - I2C3_SDA / Habilita Resistencia de Pull -Up  */


	  //inicializa funcion alterna para CAN1 RX en pin B8
	  GPIOx_InitAF(GPIOB, 8, GPIO_OTYPER_PP, GPIO_OSPEEDR_HS, 9 , false); /*Puerto B / PIN 8 / Configura Push Pull / High speed /  Función alterna 9 - CAN1_RX / Habilita Resistencia de Pull -Up  */
	  //inicializa funcion alterna para CAN1 TX en pin B9
	  GPIOx_InitAF(GPIOB, 9, GPIO_OTYPER_PP, GPIO_OSPEEDR_HS, 9 , false); /*Puerto B / PIN 9 / Configura Push Pull / High speed /  Función alterna 9 - CAN1_TX / Habilita Resistencia de Pull -Up  */

	  // Inicializa función alterna para USART3
	  GPIOx_InitAF(GPIOB, 10, GPIO_OTYPER_PP, 0, 7, false); // USART3_TX en PB10
	  GPIOx_InitAF(GPIOB, 11, GPIO_OTYPER_PP, 0, 7, true);  // USART3_RX en PB11 con Pull-Up
}

void MPU6050_Read_Ace_Giro(void){
	  AC_X =  MPU6050_Read(MPU6050_ACCEL_XOUT_H);
	  AX=(AC_X/16384.0);
	  AC_Y =  MPU6050_Read(MPU6050_ACCEL_YOUT_H);
	  AY=(AC_Y/16384.0);
	  AC_Z =  MPU6050_Read(MPU6050_ACCEL_ZOUT_H);
	  AZ=(AC_Z/16384.0);
	  G_X =  MPU6050_Read(MPU6050_GYRO_XOUT_H);
	  GX=(G_X/131.0);
	  G_Y =  MPU6050_Read(MPU6050_GYRO_YOUT_H);
	  GY=(G_Y/131.0);
	  G_Z = MPU6050_Read(MPU6050_GYRO_ZOUT_H);
	  GZ=(G_Z/131.0);
}

void SecuanciaInicio(void){
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, 0X2E); //Escrollin off
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, 0xA5);
	  I2C_delay(1000000);
	 // GPIOC->ODR ^= 0x00002000;
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, 0xA4);
	  I2C_delay(1000000);
	//  GPIOC->ODR ^= 0x00002000;
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, 0xA5);
	  I2C_delay(1000000);
	//  GPIOC->ODR ^= 0x00002000;
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, 0xA4);
	  I2C_delay(1000000);
	//  GPIOC->ODR ^= 0x00002000;
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, 0xA5);
	  I2C_delay(1000000);
	//  GPIOC->ODR ^= 0x00002000;
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, 0xA4);
	  I2C_delay(1000000);
	//  GPIOC->ODR ^= 0x00002000;
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE1);
	  SSD1306_PosCom(0);
	  SSD1306_WriteString("  ! LIESE LAB 2024 ! ");
	  I2C_delay(2000000);
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE3);
	  SSD1306_PosCom(0);
	  SSD1306_WriteString("                                ");
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE3);
	  SSD1306_PosCom(0);
	  SSD1306_WriteString("! TELEMETRY SYSTEM !");
	  I2C_delay(2000000);
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE5);
	  SSD1306_PosCom(0);
	  SSD1306_WriteString("                                ");
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE5);
	  SSD1306_PosCom(0);
	  SSD1306_WriteString("  ! SCANNER OBDII ! ");
	  I2C_delay(2500000);
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, 0xA7);  // Set normal display mode (A6 = normal, A7 = inverted)
	  I2C_delay(1000000);
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, 0xA6);  // Set normal display mode (A6 = normal, A7 = inverted)
	  I2C_delay(1000000);
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, 0xA7);  // Set normal display mode (A6 = normal, A7 = inverted)
	  I2C_delay(1000000);
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, 0xA6);  // Set normal display mode (A6 = normal, A7 = inverted)
	  I2C_delay(1000000);
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, 0xA7);  // Set normal display mode (A6 = normal, A7 = inverted)
	  I2C_delay(1000000);
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, 0xA6);  // Set normal display mode (A6 = normal, A7 = inverted)
	  I2C_delay(1000000);
	  SSD1306_Clear();
}


void delay(uint32_t n)
{
	while(n--);
}


void CAN1_RX0_IRQHandler(){
	NVIC_ClearPendingIRQ(CAN1_RX0_IRQn);
	CAN1_Rx0_FIFOx (CAN1, FIFOmailBox0);
	receivedData0_L = CAN1->sFIFOMailBox[0].RDLR;
	receivedData0_H = CAN1->sFIFOMailBox[0].RDHR;
    PID = (receivedData0_L & 0x00FF0000) >> 16;
}
void CAN1_RX1_IRQHandler(){
     NVIC_ClearPendingIRQ(CAN1_RX1_IRQn);
     CAN1_Rx1_FIFOx (CAN1, FIFOmailBox1);
     receivedData1_L = CAN1->sFIFOMailBox[1].RDLR;
     receivedData1_H = CAN1->sFIFOMailBox[1].RDHR;
     PID = (receivedData1_L & 0x00FF0000) >> 16;
}


// Función que envía un mensaje por UART según el caso seleccionado
void sendMessage(uint8_t caseNumber) {
    switch(caseNumber) {
        case 1:

            break;
        case 2:

        default:
            break;
    }
}

void sendMessage_http_field1(uint16_t fieldValue){
    sendStringUARTx(USART3,"AT+QICSGP=1,1,\"internet.itelcel.com\",\"webgprs\",\"webgprs2002\",1");
    delay(200000);
    sendStringUARTx(USART3, "AT+QIACT=1\r\n\0");
    delay(200000);
    sendStringUARTx(USART3, "AT+QIACT?\r\n\0");
    delay(200000);
    sendStringUARTx(USART3, "AT+QHTTPCFG=\"contextid\",1\r\n\0");
    delay(200000);
    sendStringUARTx(USART3, "AT+QHTTPURL=71,30\r\n\0");
    delay(200000);
    char url[100];  // Asegúrate de que el tamaño sea adecuado
    snprintf(url, sizeof(url), "https://api.thingspeak.com/update?api_key=D2SHDYLUTSW1PFRW&field1=%d\r\n\0", fieldValue);
    sendStringUARTx(USART3, url);
    delay(200000);
    sendStringUARTx(USART3, "AT+QHTTPGET=15\r\n\0");
    delay(200000);
    sendStringUARTx(USART3, "AT+QHTTPGET=15\r\n\0");
   delay(200000);
}

void sendMessage_http_field2(uint16_t fieldValue){
    sendStringUARTx(USART3,"AT+QICSGP=1,1,\"internet.itelcel.com\",\"webgprs\",\"webgprs2002\",1");
    delay(100000);
    sendStringUARTx(USART3, "AT+QIACT=1\r\n\0");
    delay(100000);
    sendStringUARTx(USART3, "AT+QIACT?\r\n\0");
    delay(100000);
    sendStringUARTx(USART3, "AT+QHTTPCFG=\"contextid\",1\r\n\0");
    delay(100000);
    sendStringUARTx(USART3, "AT+QHTTPURL=71,30\r\n\0");
    delay(100000);
    char url[100];  // Asegúrate de que el tamaño sea adecuado
    snprintf(url, sizeof(url), "https://api.thingspeak.com/update?api_key=D2SHDYLUTSW1PFRW&field2=%d\r\n\0", fieldValue);
    sendStringUARTx(USART3, url);
    delay(100000);
    sendStringUARTx(USART3, "AT+QHTTPGET=30\r\n\0");
    delay(100000);
    sendStringUARTx(USART3, "AT+QHTTPGET=30\r\n\0");
    delay(100000);
}

void sendMessage_http_field3(uint16_t fieldValue){
    sendStringUARTx(USART3,"AT+QICSGP=1,1,\"internet.itelcel.com\",\"webgprs\",\"webgprs2002\",1");
    delay(100000);
    sendStringUARTx(USART3, "AT+QIACT=1\r\n\0");
    delay(100000);
    sendStringUARTx(USART3, "AT+QIACT?\r\n\0");
    delay(100000);
    sendStringUARTx(USART3, "AT+QHTTPCFG=\"contextid\",1\r\n\0");
    delay(100000);
    sendStringUARTx(USART3, "AT+QHTTPURL=71,30\r\n\0");
    delay(100000);
    char url[100];  // Asegúrate de que el tamaño sea adecuado
    snprintf(url, sizeof(url), "https://api.thingspeak.com/update?api_key=D2SHDYLUTSW1PFRW&field3=%d\r\n\0", fieldValue);
    sendStringUARTx(USART3, url);
    delay(100000);
    sendStringUARTx(USART3, "AT+QHTTPGET=30\r\n\0");
    delay(100000);
    sendStringUARTx(USART3, "AT+QHTTPGET=30\r\n\0");
    delay(100000);
}


/* *****************************************************************************
 * Función para enviar datos a través de HTTP con el valor del campo 4
 * *****************************************************************************/
void sendMessage_http_field4(uint16_t fieldValue) {
    sendStringUARTx(USART3, "AT+QICSGP=1,1,\"internet.itelcel.com\",\"webgprs\",\"webgprs2002\",1");
    delay(100000);

    sendStringUARTx(USART3, "AT+QIACT=1\r\n\0");
    delay(100000);

    sendStringUARTx(USART3, "AT+QIACT?\r\n\0");
    delay(100000);

    sendStringUARTx(USART3, "AT+QHTTPCFG=\"contextid\",1\r\n\0");
    delay(100000);

    sendStringUARTx(USART3, "AT+QHTTPURL=71,30\r\n\0");
    delay(100000);

    char url[100];
    snprintf(url, sizeof(url), "https://api.thingspeak.com/update?api_key=D2SHDYLUTSW1PFRW&field4=%d\r\n\0", fieldValue);
    sendStringUARTx(USART3, url);
    delay(100000);

    sendStringUARTx(USART3, "AT+QHTTPGET=30\r\n\0");
    delay(100000);

    sendStringUARTx(USART3, "AT+QHTTPGET=30\r\n\0");
    delay(100000);
}


/* *****************************************************************************
 * Función para enviar datos a través de HTTP con el valor del campo 4
 * *****************************************************************************/
void sendMessage_Cell(int number) {

    char message[100]; // Buffer para el mensaje
    sprintf(message, "Pruebas 09/12/24 GSM/STM32L452RE %d\r\n", number);

    sendStringUARTx(USART3, "AT+CMGF=1\r\n\0");
    delay(100000);

    sendStringUARTx(USART3, "AT+CSCS=\"GSM\"\r\n\0");
    delay(100000);

    sendStringUARTx(USART3, "AT+CMGS=\"5617951874\"\r\n\0");
    delay(100000);

    sendStringUARTx(USART3, message); // Envía el mensaje con el número
    delay(100000);

    sendByteUARTx(USART3, 0x1A); // Carácter Ctrl+Z para finalizar el mensaje SMS
    delay(100000);

}


/* *****************************************************************************
 * Función para enviar un mensaje OBD-II con un PID específico
 * *****************************************************************************/
void Obdii_Message(uint32_t Obdii_pid) {
    CAN_MailboxConfig(CAN1, false, 0x7DF, false, 0x0); // Configuración del buzón CAN
    CAN_SendData(CAN1, 8, Obdii_pid, 0x0);            // Enviar mensaje CAN
    CAN_RequestTransmission(CAN1, 0x0);               // Solicitar transmisión CAN
}

/* *****************************************************************************
 * Función para obtener datos OBD-II (velocidad, RPM, temperatura, combustible)
 * *****************************************************************************/
void Get_Obdii_Data(void) {

	// Petición de la velocidad
	//Limpiar Bytes
    ByteA = 0;
    ByteB = 0;
    ByteC = 0;
    ByteD = 0;

    delay(100);
    Obdii_Message(PID_0D);    //Enviar mensaje de peticion OBDII de la velociad
    delay(10000);

    //Filtrar cada Byte del mensaje de respuesta
    ByteA = (CAN1->sFIFOMailBox[0].RDLR & 0xFF000000) >> 24;
    ByteB = (CAN1->sFIFOMailBox[0].RDHR & 0x000000FF);
    ByteC = (CAN1->sFIFOMailBox[0].RDHR & 0x0000FF00) >> 8;
    ByteD = (CAN1->sFIFOMailBox[0].RDHR& 0x00FF0000) >> 16;

    Vel_Km = ByteA; //Formlula para interpertar la velocidad


	// Petición de las RPM
	//Limpiar Bytes
    ByteA = 0;
    ByteB = 0;
    ByteC = 0;
    ByteD = 0;

    delay(100);
    Obdii_Message(PID_0C);    //Enviar mensaje de peticion OBDII de las RPM
    delay(10000);

    //Filtra cada Byte del mensaje de repuesta
    ByteA = (CAN1->sFIFOMailBox[0].RDLR & 0xFF000000) >> 24;
    ByteB = (CAN1->sFIFOMailBox[0].RDHR & 0x000000FF);
    ByteC = (CAN1->sFIFOMailBox[0].RDHR & 0x0000FF00) >> 8;
    ByteD = (CAN1->sFIFOMailBox[0].RDHR& 0x00FF0000) >> 16;

    RPM_motor = (256 * ByteA + ByteB) / 4; //Formula para interpretar las RPM del motor

	// Petición del liquido de enfriamiento
	//Limpiar Bytes
    ByteA = 0;
    ByteB = 0;
    ByteC = 0;
    ByteD = 0;

    delay(100);
    Obdii_Message(PID_05);    //Enviar mensaje de peticion OBDII para el liquido de enfriamiento
    delay(10000);

    //Filtra cada Byte del mensaje de la respuesta del liquido de enfriamiento
    ByteA = (CAN1->sFIFOMailBox[0].RDLR & 0xFF000000) >> 24;
    ByteB = (CAN1->sFIFOMailBox[0].RDHR & 0x000000FF);
    ByteC = (CAN1->sFIFOMailBox[0].RDHR & 0x0000FF00) >> 8;
    ByteD = (CAN1->sFIFOMailBox[0].RDHR& 0x00FF0000) >> 16;

    Temp_liquido = ByteA - 40; //Formula para interpretar la temperatura del liquido de enfriamiento

	// Petición del nivel de combustible
	//Limpiar Bytes
    ByteA = 0;
    ByteB = 0;
    ByteC = 0;
    ByteD = 0;

    delay(100);
    Obdii_Message(PID_2F);	//Enviar mensaje de peticion OBDII del nivel de combustible
    delay(10000);

    //Filtra cada Byte del mensaje de la respuesta del nivel de combustible
    ByteA = (CAN1->sFIFOMailBox[0].RDLR & 0xFF000000) >> 24;
    ByteB = (CAN1->sFIFOMailBox[0].RDHR & 0x000000FF);
    ByteC = (CAN1->sFIFOMailBox[0].RDHR & 0x0000FF00) >> 8;
    ByteD = (CAN1->sFIFOMailBox[0].RDHR& 0x00FF0000) >> 16;

    Combustible = (ByteA * 100) / 255; //Formula para interpretar el nivel de combustible

}

void SSD1306_Refresh (void){
char buffer[10]; // Espacio para almacenar la representación en cadena
I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE3);
SSD1306_PosCom(80);
SSD1306_WriteString("            ");
I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE3);
SSD1306_PosCom(80);
sprintf(buffer, "%d", Vel_Km);
SSD1306_WriteString(buffer); // Escribe la cadena en la pantalla OLED
SSD1306_WriteString(" KM");
I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE5);
SSD1306_PosCom(50);
SSD1306_WriteString("               ");
I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE5);
SSD1306_PosCom(50);
sprintf(buffer, "%d", RPM_motor);
SSD1306_WriteString(buffer); // Escribe la cadena en la pantalla OLED
SSD1306_WriteString(" RPM");
I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE7);
SSD1306_PosCom(70);
SSD1306_WriteString("              ");
I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE7);
SSD1306_PosCom(70);
sprintf(buffer, "%d", Combustible);
SSD1306_WriteString(buffer); // Escribe la cadena en la pantalla OLED
SSD1306_WriteString("  T");
}


void Send_Telemetry (void){

    sendMessage_http_field4(Combustible);

    //sendMessage_http_field3(Vel_Km);
    //delay(1000000);

    /*
    sendMessage_http_field2(RPM_motor);
    delay(1000000);
    sendMessage_http_field3(Temp_liquido);
    delay(1000000);
    sendMessage_http_field4(Combustible);
    delay(1000000);
    */
}




